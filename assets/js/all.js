(function ( window, document, $ ) {
  var metaQuery = {
    breakpoints: {},
    _events: {},
    _eventMatchCache: {},
    bind: function ( name, fn ) {
      ( metaQuery._events[name] = [] ).push( fn );

      mqChange();
    }
  },

  debounce = function( func, wait ) {
    var args,
        thisArg,
        timeoutId;

    function delayed() {
      timeoutId = null;
      func.apply( thisArg, args );
    }

    return function() {
      window.clearTimeout( timeoutId );
      timeoutId = window.setTimeout( delayed, wait );
    };
  },

  updateClasses = function ( matches, name ) {
    $( 'html' ).toggleClass( 'breakpoint-' + name, matches );
  },

  updateElements = function ( matches, name ) {
    if ( !matches ) { return; }

    $( 'img[data-mq-src]' ).each(function () {
      var $img = $( this ),
          attr = $img.attr( 'data-mq-src');

      $img.attr( 'src', attr.replace( '[breakpoint]', name ) );
    });
  },

  // Called when a media query changes state
  mqChange = function () {
    for ( var name in metaQuery.breakpoints ) {
      var query = metaQuery.breakpoints[name],
          matches = window.matchMedia( query ).matches;

      // Call events bound to a given breakpoint
      if ( metaQuery._events[name] && metaQuery._eventMatchCache[name] !== matches ) {
        for( var i = 0; i < metaQuery._events[name].length; i++ ) {
          var fn = metaQuery._events[name][i];
          metaQuery._eventMatchCache[name] = matches;

          if( typeof fn === 'function' ) { fn( matches ); }
        }
      }

      updateClasses( matches, name );
      updateElements( matches, name );
    }
  },

  collectMediaQueries = function () {
    $( 'meta[name=breakpoint]' ).each( function () {
      var $el = $( this );
      metaQuery.breakpoints[$el.attr( 'content' )] = $el.attr( 'media' );
    });
  },


  // If the META tags are defined above this script,
  // we don't need to wait for domReady to set the breakpoint
  // class on the HTML element, fighting the FOUT.
  preDomReady = function () {
    collectMediaQueries();
    mqChange();
  },

  // After domReady, we can be sure all our META and IMG tags
  // are in the DOM.
  onDomReady = function () {
    collectMediaQueries();

    $( window ).on( 'resize', debounce ( function () {
      mqChange();
    }, 50));

    mqChange();
  };

  window.metaQuery = metaQuery;

  preDomReady();
  $(function () {
    onDomReady();
  });
}( this, this.document, jQuery ));

// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  (function($, window, document) {
    var Sidenote, SidenoteGroup, SidenotesPlugin, escapeExpression;
    $.fn.extend({
      sidenotes: function() {
        var args, option;
        option = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return this.each(function() {
          var $this, plugin, _ref;
          $this = $(this);
          plugin = (_ref = $this.data('sidenotes')) != null ? _ref : $this.data('sidenotes', new SidenotesPlugin(this, option));
          if (typeof option === 'string') {
            plugin[option].apply(plugin, args);
            if (option === 'destroy') {
              $this.removeData('sidenotes');
            }
          }
          return true;
        });
      }
    });
    SidenotesPlugin = (function() {
      SidenotesPlugin.prototype.options = {
        footnoteContainerSelector: '.footnotes',
        footnoteSelector: '> ol > li',
        initiallyHidden: false,
        removeRefMarkRegex: /(?!)/,
        refMarkClass: 'ref-mark',
        sidenoteClass: 'sidenote',
        sidenoteGroupClass: 'sidenote-group',
        sidenoteElement: 'aside',
        sidenoteGroupElement: 'div',
        sidenotePlacement: 'before',
        hideFootnoteContainer: true,
        formatSidenote: function(footnoteHtml, id, ref) {
          var $sidenote;
          $sidenote = $("<" + this.sidenoteElement + "/>", {
            "class": this.sidenoteClass
          }).html(footnoteHtml).attr('id', id);
          if (ref != null) {
            $sidenote.attr('data-ref', ref);
            $sidenote.prepend($('<span/>', {
              "class": this.refMarkClass
            }).html(ref));
          }
          return $sidenote;
        },
        formatSidenoteID: function(footnoteID) {
          return footnoteID.replace(/^f/, 's');
        },
        hide: function($el) {
          return $el.hide();
        },
        show: function($el) {
          return $el.show();
        }
      };

      function SidenotesPlugin(scope, options) {
        var plugin, refCounter;
        this.options = $.extend({}, this.options, options);
        this.options.sidenotePlacement = this.options.placement || this.options.sidenotePlacement;
        if (this.options.hideFootnoteContainer) {
          this.$footnoteContainer = $(this.options.footnoteContainerSelector, scope);
        }
        this.$footnoteContainer = this.$footnoteContainer.size() !== 0 ? this.$footnoteContainer : null;
        this.$postContainer = this.$footnoteContainer.parent();
        this.$footnotes = $(this.options.footnoteContainerSelector + ' ' + this.options.footnoteSelector, this.$postContainer);
        this.sidenotesAfterRef = this.options.sidenotePlacement === 'after';
        refCounter = 1;
        this.sidenotes = [];
        this.groups = [];
        plugin = this;
        this.$footnotes.each(function() {
          var footnoteEl, footnoteID, group, noRef, previous, sidenote, _ref;
          footnoteEl = this;
          footnoteID = footnoteEl.id;
          noRef = plugin.options.removeRefMarkRegex.test(footnoteID);
          sidenote = new Sidenote(footnoteEl, (noRef ? null : refCounter++), plugin);
          plugin.sidenotes.push(sidenote);
          previous = (_ref = plugin.sidenotes[plugin.sidenotes.length - 2]) != null ? _ref : null;
          if (previous != null ? previous.$pivot.is(sidenote.$pivot) : void 0) {
            if (previous.hasGroup()) {
              return previous.group.push(sidenote);
            } else {
              group = new SidenoteGroup([previous, sidenote], plugin);
              return plugin.groups.push(group);
            }
          }
        });
        this.isHidden = this.options.initiallyHidden;
        if (this.isHidden) {
          this.hide(true);
        } else {
          this.show(true);
        }
      }

      SidenotesPlugin.prototype.show = function(force) {
        var group, sidenote, _i, _j, _len, _len1, _ref, _ref1;
        if (this.isHidden || force) {
          _ref = this.sidenotes;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sidenote = _ref[_i];
            if (force && !sidenote.hasGroup()) {
              sidenote.$pivot[this.sidenotePlacement()](sidenote.$sidenote);
            }
            sidenote.show();
          }
          _ref1 = this.groups;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            group = _ref1[_j];
            if (force) {
              group.$pivot[this.sidenotePlacement()](group.$group);
            }
            group.show();
          }
          if ((this.$footnoteContainer != null) && this.options.hideFootnoteContainer) {
            this.options.hide(this.$footnoteContainer);
          }
          return this.isHidden = false;
        }
      };

      SidenotesPlugin.prototype.hide = function(force) {
        var group, sidenote, _i, _j, _len, _len1, _ref, _ref1;
        if (!this.isHidden || force) {
          _ref = this.sidenotes;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sidenote = _ref[_i];
            if (force && !sidenote.hasGroup()) {
              sidenote.$pivot[this.sidenotePlacement()](sidenote.$sidenote);
            }
            sidenote.hide();
          }
          _ref1 = this.groups;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            group = _ref1[_j];
            if (force) {
              group.$pivot[this.sidenotePlacement()](group.$group);
            }
            group.hide();
          }
          if (this.$footnoteContainer != null) {
            this.options.show(this.$footnoteContainer);
          }
          return this.isHidden = true;
        }
      };

      SidenotesPlugin.prototype.sidenotePlacement = function(placement, force) {
        var group, sidenote, _i, _j, _len, _len1, _ref, _ref1;
        if ((placement === 'before' || placement === 'after') && (placement !== this.sidenotePlacement() || force)) {
          _ref = this.sidenotes;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sidenote = _ref[_i];
            if (!sidenote.hasGroup()) {
              sidenote.$pivot[placement](sidenote.$sidenote);
            }
          }
          _ref1 = this.groups;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            group = _ref1[_j];
            group.$pivot[placement](group.$group);
          }
          return this.sidenotesAfterRef = placement === 'after';
        } else {
          if (this.sidenotesAfterRef) {
            return 'after';
          } else {
            return 'before';
          }
        }
      };

      SidenotesPlugin.prototype.placement = function(placement, force) {
        return this.sidenotePlacement(placement, force);
      };

      SidenotesPlugin.prototype.destroy = function() {
        var group, sidenote, _i, _j, _len, _len1, _ref, _ref1, _results;
        this.hide();
        _ref = this.sidenotes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          sidenote = _ref[_i];
          sidenote.$sidenote.remove();
        }
        _ref1 = this.groups;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _results.push(group.$group.remove());
        }
        return _results;
      };

      return SidenotesPlugin;

    })();
    Sidenote = (function() {
      function Sidenote(footnoteEl, ref, owner) {
        var $backArrow, $referringFootnote, sidenote, _i, _len, _ref;
        this.$footnote = $(footnoteEl);
        this.owner = owner;
        this.footnoteID = footnoteEl.id;
        this.sidenoteID = this.owner.options.formatSidenoteID(this.footnoteID);
        this.ref = ref > 0 ? ref : null;
        this.$refMarkAnchor = $("a[href='#" + (escapeExpression(this.footnoteID)) + "']", this.owner.$postContainer);
        this.$refMarkSup = this.$refMarkAnchor.parent('sup');
        this.$refMarkSup = this.$refMarkSup.size() !== 0 ? this.$refMarkSup : null;
        this.isNested = $.contains(this.owner.$footnoteContainer.get(0), this.refMark().get(0));
        if (this.isNested) {
          $referringFootnote = this.refMark().closest(this.owner.$footnotes);
          _ref = this.owner.sidenotes;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sidenote = _ref[_i];
            if (sidenote.$footnote.is($referringFootnote)) {
              this.referringSidenote = sidenote;
              break;
            }
          }
        }
        this.refMarkID = this.refMark().attr('id');
        this.originalRef = this.$refMarkAnchor.html();
        this.$sidenote = this.owner.options.formatSidenote(this.$footnote.html(), this.sidenoteID, this.ref);
        this.$pivot = !this.isNested ? this.refMark().parentsUntil(this.owner.$postContainer).last() : this.referringSidenote.$pivot;
        this.group = null;
        $backArrow = $("a[href='#" + (escapeExpression(this.refMarkID)) + "']", this.$sidenote);
        if (($backArrow != null) && this.noMark()) {
          this.owner.options.hide($backArrow);
        }
        this.owner.options.hide(this.$sidenote);
        this.isHidden = true;
      }

      Sidenote.prototype.noMark = function() {
        return this.ref == null;
      };

      Sidenote.prototype.hasGroup = function() {
        return this.group != null;
      };

      Sidenote.prototype.show = function(force) {
        if (this.isHidden || force) {
          if (this.noMark()) {
            this.owner.options.hide(this.refMark());
          } else {
            this.$refMarkAnchor.html(this.ref);
            this.$refMarkAnchor.attr('href', "#" + this.sidenoteID);
          }
          this.owner.options.show(this.$sidenote);
          this.owner.options.hide(this.$footnote);
          return this.isHidden = false;
        }
      };

      Sidenote.prototype.hide = function(force) {
        if (!this.isHidden || force) {
          this.$refMarkAnchor.html(this.originalRef);
          this.$refMarkAnchor.attr('href', "#" + this.footnoteID);
          this.owner.options.show(this.refMark());
          this.owner.options.hide(this.$sidenote);
          this.owner.options.show(this.$footnote);
          return this.isHidden = true;
        }
      };

      Sidenote.prototype.refMark = function() {
        var _ref;
        return (_ref = this.$refMarkSup) != null ? _ref : this.$refMarkAnchor;
      };

      return Sidenote;

    })();
    SidenoteGroup = (function() {
      function SidenoteGroup(sidenotes, owner) {
        var _ref;
        this.sidenotes = [];
        this.owner = owner;
        this.$group = $("<" + this.owner.options.sidenoteGroupElement + "/>", {
          "class": this.owner.options.sidenoteGroupClass
        });
        this.push(sidenotes);
        this.$pivot = (_ref = this.sidenotes[0]) != null ? _ref.$pivot : void 0;
        this.owner.options.hide(this.$group);
        this.isHidden = true;
      }

      SidenoteGroup.prototype.push = function(s) {
        var sidenote, sidenotes, _i, _len, _ref;
        sidenotes = s instanceof Array ? s : [s];
        (_ref = this.sidenotes).push.apply(_ref, sidenotes);
        for (_i = 0, _len = sidenotes.length; _i < _len; _i++) {
          sidenote = sidenotes[_i];
          this.$group.append(sidenote.$sidenote);
          sidenote.group = this;
        }
        return this.$pivot != null ? this.$pivot : this.$pivot = this.sidenotes[0].pivot;
      };

      SidenoteGroup.prototype.show = function() {
        if (this.isHidden) {
          this.owner.options.show(this.$group);
          return this.isHidden = false;
        }
      };

      SidenoteGroup.prototype.hide = function() {
        if (!this.isHidden) {
          this.owner.options.hide(this.$group);
          return this.isHidden = true;
        }
      };

      return SidenoteGroup;

    })();
    return escapeExpression = function(str) {
      return str.replace(/([#;&,\.\+\*\~':"\!\^$\[\]\(\)=>\|])/g, '\\$1');
    };
  })(jQuery, window, document);

}).call(this);

/*
//@ sourceMappingURL=jquery.sidenotes.map
*/

/*!
Waypoints - 3.1.1
Copyright © 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blog/master/licenses.txt
*/
(function() {
  'use strict'

  var keyCounter = 0
  var allWaypoints = {}

  /* http://imakewebthings.com/waypoints/api/waypoint */
  function Waypoint(options) {
    if (!options) {
      throw new Error('No options passed to Waypoint constructor')
    }
    if (!options.element) {
      throw new Error('No element option passed to Waypoint constructor')
    }
    if (!options.handler) {
      throw new Error('No handler option passed to Waypoint constructor')
    }

    this.key = 'waypoint-' + keyCounter
    this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options)
    this.element = this.options.element
    this.adapter = new Waypoint.Adapter(this.element)
    this.callback = options.handler
    this.axis = this.options.horizontal ? 'horizontal' : 'vertical'
    this.enabled = this.options.enabled
    this.triggerPoint = null
    this.group = Waypoint.Group.findOrCreate({
      name: this.options.group,
      axis: this.axis
    })
    this.context = Waypoint.Context.findOrCreateByElement(this.options.context)

    if (Waypoint.offsetAliases[this.options.offset]) {
      this.options.offset = Waypoint.offsetAliases[this.options.offset]
    }
    this.group.add(this)
    this.context.add(this)
    allWaypoints[this.key] = this
    keyCounter += 1
  }

  /* Private */
  Waypoint.prototype.queueTrigger = function(direction) {
    this.group.queueTrigger(this, direction)
  }

  /* Private */
  Waypoint.prototype.trigger = function(args) {
    if (!this.enabled) {
      return
    }
    if (this.callback) {
      this.callback.apply(this, args)
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/destroy */
  Waypoint.prototype.destroy = function() {
    this.context.remove(this)
    this.group.remove(this)
    delete allWaypoints[this.key]
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/disable */
  Waypoint.prototype.disable = function() {
    this.enabled = false
    return this
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/enable */
  Waypoint.prototype.enable = function() {
    this.context.refresh()
    this.enabled = true
    return this
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/next */
  Waypoint.prototype.next = function() {
    return this.group.next(this)
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/previous */
  Waypoint.prototype.previous = function() {
    return this.group.previous(this)
  }

  /* Private */
  Waypoint.invokeAll = function(method) {
    var allWaypointsArray = []
    for (var waypointKey in allWaypoints) {
      allWaypointsArray.push(allWaypoints[waypointKey])
    }
    for (var i = 0, end = allWaypointsArray.length; i < end; i++) {
      allWaypointsArray[i][method]()
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/destroy-all */
  Waypoint.destroyAll = function() {
    Waypoint.invokeAll('destroy')
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/disable-all */
  Waypoint.disableAll = function() {
    Waypoint.invokeAll('disable')
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/enable-all */
  Waypoint.enableAll = function() {
    Waypoint.invokeAll('enable')
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/refresh-all */
  Waypoint.refreshAll = function() {
    Waypoint.Context.refreshAll()
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/viewport-height */
  Waypoint.viewportHeight = function() {
    return window.innerHeight || document.documentElement.clientHeight
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/viewport-width */
  Waypoint.viewportWidth = function() {
    return document.documentElement.clientWidth
  }

  Waypoint.adapters = []

  Waypoint.defaults = {
    context: window,
    continuous: true,
    enabled: true,
    group: 'default',
    horizontal: false,
    offset: 0
  }

  Waypoint.offsetAliases = {
    'bottom-in-view': function() {
      return this.context.innerHeight() - this.adapter.outerHeight()
    },
    'right-in-view': function() {
      return this.context.innerWidth() - this.adapter.outerWidth()
    }
  }

  window.Waypoint = Waypoint
}())
;(function() {
  'use strict'

  function requestAnimationFrameShim(callback) {
    window.setTimeout(callback, 1000 / 60)
  }

  var keyCounter = 0
  var contexts = {}
  var Waypoint = window.Waypoint
  var oldWindowLoad = window.onload

  /* http://imakewebthings.com/waypoints/api/context */
  function Context(element) {
    this.element = element
    this.Adapter = Waypoint.Adapter
    this.adapter = new this.Adapter(element)
    this.key = 'waypoint-context-' + keyCounter
    this.didScroll = false
    this.didResize = false
    this.oldScroll = {
      x: this.adapter.scrollLeft(),
      y: this.adapter.scrollTop()
    }
    this.waypoints = {
      vertical: {},
      horizontal: {}
    }

    element.waypointContextKey = this.key
    contexts[element.waypointContextKey] = this
    keyCounter += 1

    this.createThrottledScrollHandler()
    this.createThrottledResizeHandler()
  }

  /* Private */
  Context.prototype.add = function(waypoint) {
    var axis = waypoint.options.horizontal ? 'horizontal' : 'vertical'
    this.waypoints[axis][waypoint.key] = waypoint
    this.refresh()
  }

  /* Private */
  Context.prototype.checkEmpty = function() {
    var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal)
    var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical)
    if (horizontalEmpty && verticalEmpty) {
      this.adapter.off('.waypoints')
      delete contexts[this.key]
    }
  }

  /* Private */
  Context.prototype.createThrottledResizeHandler = function() {
    var self = this

    function resizeHandler() {
      self.handleResize()
      self.didResize = false
    }

    this.adapter.on('resize.waypoints', function() {
      if (!self.didResize) {
        self.didResize = true
        Waypoint.requestAnimationFrame(resizeHandler)
      }
    })
  }

  /* Private */
  Context.prototype.createThrottledScrollHandler = function() {
    var self = this
    function scrollHandler() {
      self.handleScroll()
      self.didScroll = false
    }

    this.adapter.on('scroll.waypoints', function() {
      if (!self.didScroll || Waypoint.isTouch) {
        self.didScroll = true
        Waypoint.requestAnimationFrame(scrollHandler)
      }
    })
  }

  /* Private */
  Context.prototype.handleResize = function() {
    Waypoint.Context.refreshAll()
  }

  /* Private */
  Context.prototype.handleScroll = function() {
    var triggeredGroups = {}
    var axes = {
      horizontal: {
        newScroll: this.adapter.scrollLeft(),
        oldScroll: this.oldScroll.x,
        forward: 'right',
        backward: 'left'
      },
      vertical: {
        newScroll: this.adapter.scrollTop(),
        oldScroll: this.oldScroll.y,
        forward: 'down',
        backward: 'up'
      }
    }

    for (var axisKey in axes) {
      var axis = axes[axisKey]
      var isForward = axis.newScroll > axis.oldScroll
      var direction = isForward ? axis.forward : axis.backward

      for (var waypointKey in this.waypoints[axisKey]) {
        var waypoint = this.waypoints[axisKey][waypointKey]
        var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint
        var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint
        var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint
        var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint
        if (crossedForward || crossedBackward) {
          waypoint.queueTrigger(direction)
          triggeredGroups[waypoint.group.id] = waypoint.group
        }
      }
    }

    for (var groupKey in triggeredGroups) {
      triggeredGroups[groupKey].flushTriggers()
    }

    this.oldScroll = {
      x: axes.horizontal.newScroll,
      y: axes.vertical.newScroll
    }
  }

  /* Private */
  Context.prototype.innerHeight = function() {
    /*eslint-disable eqeqeq */
    if (this.element == this.element.window) {
      return Waypoint.viewportHeight()
    }
    /*eslint-enable eqeqeq */
    return this.adapter.innerHeight()
  }

  /* Private */
  Context.prototype.remove = function(waypoint) {
    delete this.waypoints[waypoint.axis][waypoint.key]
    this.checkEmpty()
  }

  /* Private */
  Context.prototype.innerWidth = function() {
    /*eslint-disable eqeqeq */
    if (this.element == this.element.window) {
      return Waypoint.viewportWidth()
    }
    /*eslint-enable eqeqeq */
    return this.adapter.innerWidth()
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/context-destroy */
  Context.prototype.destroy = function() {
    var allWaypoints = []
    for (var axis in this.waypoints) {
      for (var waypointKey in this.waypoints[axis]) {
        allWaypoints.push(this.waypoints[axis][waypointKey])
      }
    }
    for (var i = 0, end = allWaypoints.length; i < end; i++) {
      allWaypoints[i].destroy()
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/context-refresh */
  Context.prototype.refresh = function() {
    /*eslint-disable eqeqeq */
    var isWindow = this.element == this.element.window
    /*eslint-enable eqeqeq */
    var contextOffset = this.adapter.offset()
    var triggeredGroups = {}
    var axes

    this.handleScroll()
    axes = {
      horizontal: {
        contextOffset: isWindow ? 0 : contextOffset.left,
        contextScroll: isWindow ? 0 : this.oldScroll.x,
        contextDimension: this.innerWidth(),
        oldScroll: this.oldScroll.x,
        forward: 'right',
        backward: 'left',
        offsetProp: 'left'
      },
      vertical: {
        contextOffset: isWindow ? 0 : contextOffset.top,
        contextScroll: isWindow ? 0 : this.oldScroll.y,
        contextDimension: this.innerHeight(),
        oldScroll: this.oldScroll.y,
        forward: 'down',
        backward: 'up',
        offsetProp: 'top'
      }
    }

    for (var axisKey in axes) {
      var axis = axes[axisKey]
      for (var waypointKey in this.waypoints[axisKey]) {
        var waypoint = this.waypoints[axisKey][waypointKey]
        var adjustment = waypoint.options.offset
        var oldTriggerPoint = waypoint.triggerPoint
        var elementOffset = 0
        var freshWaypoint = oldTriggerPoint == null
        var contextModifier, wasBeforeScroll, nowAfterScroll
        var triggeredBackward, triggeredForward

        if (waypoint.element !== waypoint.element.window) {
          elementOffset = waypoint.adapter.offset()[axis.offsetProp]
        }

        if (typeof adjustment === 'function') {
          adjustment = adjustment.apply(waypoint)
        }
        else if (typeof adjustment === 'string') {
          adjustment = parseFloat(adjustment)
          if (waypoint.options.offset.indexOf('%') > - 1) {
            adjustment = Math.ceil(axis.contextDimension * adjustment / 100)
          }
        }

        contextModifier = axis.contextScroll - axis.contextOffset
        waypoint.triggerPoint = elementOffset + contextModifier - adjustment
        wasBeforeScroll = oldTriggerPoint < axis.oldScroll
        nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll
        triggeredBackward = wasBeforeScroll && nowAfterScroll
        triggeredForward = !wasBeforeScroll && !nowAfterScroll

        if (!freshWaypoint && triggeredBackward) {
          waypoint.queueTrigger(axis.backward)
          triggeredGroups[waypoint.group.id] = waypoint.group
        }
        else if (!freshWaypoint && triggeredForward) {
          waypoint.queueTrigger(axis.forward)
          triggeredGroups[waypoint.group.id] = waypoint.group
        }
        else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {
          waypoint.queueTrigger(axis.forward)
          triggeredGroups[waypoint.group.id] = waypoint.group
        }
      }
    }

    for (var groupKey in triggeredGroups) {
      triggeredGroups[groupKey].flushTriggers()
    }

    return this
  }

  /* Private */
  Context.findOrCreateByElement = function(element) {
    return Context.findByElement(element) || new Context(element)
  }

  /* Private */
  Context.refreshAll = function() {
    for (var contextId in contexts) {
      contexts[contextId].refresh()
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/context-find-by-element */
  Context.findByElement = function(element) {
    return contexts[element.waypointContextKey]
  }

  window.onload = function() {
    if (oldWindowLoad) {
      oldWindowLoad()
    }
    Context.refreshAll()
  }

  Waypoint.requestAnimationFrame = function(callback) {
    var requestFn = window.requestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      requestAnimationFrameShim
    requestFn.call(window, callback)
  }
  Waypoint.Context = Context
}())
;(function() {
  'use strict'

  function byTriggerPoint(a, b) {
    return a.triggerPoint - b.triggerPoint
  }

  function byReverseTriggerPoint(a, b) {
    return b.triggerPoint - a.triggerPoint
  }

  var groups = {
    vertical: {},
    horizontal: {}
  }
  var Waypoint = window.Waypoint

  /* http://imakewebthings.com/waypoints/api/group */
  function Group(options) {
    this.name = options.name
    this.axis = options.axis
    this.id = this.name + '-' + this.axis
    this.waypoints = []
    this.clearTriggerQueues()
    groups[this.axis][this.name] = this
  }

  /* Private */
  Group.prototype.add = function(waypoint) {
    this.waypoints.push(waypoint)
  }

  /* Private */
  Group.prototype.clearTriggerQueues = function() {
    this.triggerQueues = {
      up: [],
      down: [],
      left: [],
      right: []
    }
  }

  /* Private */
  Group.prototype.flushTriggers = function() {
    for (var direction in this.triggerQueues) {
      var waypoints = this.triggerQueues[direction]
      var reverse = direction === 'up' || direction === 'left'
      waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint)
      for (var i = 0, end = waypoints.length; i < end; i += 1) {
        var waypoint = waypoints[i]
        if (waypoint.options.continuous || i === waypoints.length - 1) {
          waypoint.trigger([direction])
        }
      }
    }
    this.clearTriggerQueues()
  }

  /* Private */
  Group.prototype.next = function(waypoint) {
    this.waypoints.sort(byTriggerPoint)
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
    var isLast = index === this.waypoints.length - 1
    return isLast ? null : this.waypoints[index + 1]
  }

  /* Private */
  Group.prototype.previous = function(waypoint) {
    this.waypoints.sort(byTriggerPoint)
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
    return index ? this.waypoints[index - 1] : null
  }

  /* Private */
  Group.prototype.queueTrigger = function(waypoint, direction) {
    this.triggerQueues[direction].push(waypoint)
  }

  /* Private */
  Group.prototype.remove = function(waypoint) {
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
    if (index > -1) {
      this.waypoints.splice(index, 1)
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/first */
  Group.prototype.first = function() {
    return this.waypoints[0]
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/last */
  Group.prototype.last = function() {
    return this.waypoints[this.waypoints.length - 1]
  }

  /* Private */
  Group.findOrCreate = function(options) {
    return groups[options.axis][options.name] || new Group(options)
  }

  Waypoint.Group = Group
}())
;(function() {
  'use strict'

  var $ = window.jQuery
  var Waypoint = window.Waypoint

  function JQueryAdapter(element) {
    this.$element = $(element)
  }

  $.each([
    'innerHeight',
    'innerWidth',
    'off',
    'offset',
    'on',
    'outerHeight',
    'outerWidth',
    'scrollLeft',
    'scrollTop'
  ], function(i, method) {
    JQueryAdapter.prototype[method] = function() {
      var args = Array.prototype.slice.call(arguments)
      return this.$element[method].apply(this.$element, args)
    }
  })

  $.each([
    'extend',
    'inArray',
    'isEmptyObject'
  ], function(i, method) {
    JQueryAdapter[method] = $[method]
  })

  Waypoint.adapters.push({
    name: 'jquery',
    Adapter: JQueryAdapter
  })
  Waypoint.Adapter = JQueryAdapter
}())
;(function() {
  'use strict'

  var Waypoint = window.Waypoint

  function createExtension(framework) {
    return function() {
      var waypoints = []
      var overrides = arguments[0]

      if (framework.isFunction(arguments[0])) {
        overrides = framework.extend({}, arguments[1])
        overrides.handler = arguments[0]
      }

      this.each(function() {
        var options = framework.extend({}, overrides, {
          element: this
        })
        if (typeof options.context === 'string') {
          options.context = framework(this).closest(options.context)[0]
        }
        waypoints.push(new Waypoint(options))
      })

      return waypoints
    }
  }

  if (window.jQuery) {
    window.jQuery.fn.waypoint = createExtension(window.jQuery)
  }
  if (window.Zepto) {
    window.Zepto.fn.waypoint = createExtension(window.Zepto)
  }
}())
;
/*!
Waypoints Sticky Element Shortcut - 3.1.1
Copyright © 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blog/master/licenses.txt
*/
(function() {
  'use strict'

  var $ = window.jQuery
  var Waypoint = window.Waypoint

  /* http://imakewebthings.com/waypoints/shortcuts/sticky-elements */
  function Sticky(options) {
    this.options = $.extend({}, Waypoint.defaults, Sticky.defaults, options)
    this.element = this.options.element
    this.$element = $(this.element)
    this.createWrapper()
    this.createWaypoint()
  }

  /* Private */
  Sticky.prototype.createWaypoint = function() {
    var originalHandler = this.options.handler

    this.waypoint = new Waypoint($.extend({}, this.options, {
      element: this.wrapper,
      handler: $.proxy(function(direction) {
        var shouldBeStuck = this.options.direction.indexOf(direction) > -1
        var wrapperHeight = shouldBeStuck ? this.$element.outerHeight(true) : ''

        this.$wrapper.height(wrapperHeight)
        this.$element.toggleClass(this.options.stuckClass, shouldBeStuck)

        if (originalHandler) {
          originalHandler.call(this, direction)
        }
      }, this)
    }))
  }

  /* Private */
  Sticky.prototype.createWrapper = function() {
    this.$element.wrap(this.options.wrapper)
    this.$wrapper = this.$element.parent()
    this.wrapper = this.$wrapper[0]
  }

  /* Public */
  Sticky.prototype.destroy = function() {
    if (this.$element.parent()[0] === this.wrapper) {
      this.waypoint.destroy()
      this.$element.removeClass(this.options.stuckClass).unwrap()
    }
  }

  Sticky.defaults = {
    wrapper: '<div class="sticky-wrapper" />',
    stuckClass: 'stuck',
    direction: 'down right'
  }

  Waypoint.Sticky = Sticky
}())
;
(function() {
    $('.post-content').sidenotes();
})();

//MAKE YOUTUBE VIDEOS RESPONSIVE

jQuery(document).ready(function($){
  function responsiveIframe() {
    $('iframe').each(function(){
      var iw = $(this).width();
      var ih = $(this).height();
      var ip = $(this).parent().width();
      var ipw = ip/iw;
      var ipwh = Math.round(ih*ipw);
      $(this).css({
        'width': ip,
        'height' : ipwh,
      });
    });
  }

  responsiveIframe();

  //Call function again if window resized
  $(window).resize(function(){
    responsiveIframe();
  });

});


// Sidebar navigation
(function () {
  'use strict';

  var querySelector = document.querySelector.bind(document);

  var navdrawerContainer = querySelector('.navdrawer-container');
  var appbarElement = querySelector('.app-bar');
  var menuBtn = querySelector('.menu');
  var main = querySelector('main');
  var sticky = new Waypoint.Sticky({
    element: $('.header')[0]
  })

  function closeMenu() {
    appbarElement.classList.remove('open');
    navdrawerContainer.classList.remove('open');
  }

  function toggleMenu() {
    appbarElement.classList.toggle('open');
    navdrawerContainer.classList.toggle('open');
  }

  main.addEventListener('click', closeMenu);
  menuBtn.addEventListener('click', toggleMenu);
  navdrawerContainer.addEventListener('click', function (event) {
    if (event.target.nodeName === 'A' || event.target.nodeName === 'LI') {
      closeMenu();
    }
  });
})();
